\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{float}

\geometry{margin=2.5cm}

\title{Statistical Comparison Methodology:\\
Multi-Period Crop Rotation Optimization\\
Classical vs Quantum Approaches}
\author{OQI-UC002-DWave Project}
\date{December 11, 2025}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Executive Summary}

This document describes the exact problem formulation and solution methods for a rigorous statistical comparison between classical (Gurobi) and quantum (D-Wave QPU) optimization approaches for multi-period crop rotation planning. We test three methods:

\begin{enumerate}
    \item \textbf{Ground Truth (Gurobi)}: Classical Mixed-Integer Programming solver with 300-second timeout
    \item \textbf{Clique Decomposition (Quantum)}: Plot-by-plot decomposition using D-Wave's native clique embedding
    \item \textbf{Spatial-Temporal Decomposition (Quantum)}: Clustered spatial and temporal slicing with iterative refinement
\end{enumerate}

All three methods solve the \textit{same optimization problem}, ensuring fair comparison. We test on problem sizes: 5, 10, 15, 20, and 25 plots, with 2 runs per method per size for statistical variance analysis.

\section{Problem Formulation}

\subsection{Multi-Period Crop Rotation Problem}

We optimize crop assignments across multiple plots over multiple time periods (rotation cycles) to maximize total agricultural benefit while respecting rotation synergies and spatial interactions.

\subsubsection{Problem Dimensions}

\begin{itemize}
    \item \textbf{Plots}: $F$ plots (tested: 5, 10, 15, 20, 25)
    \item \textbf{Crop Families}: $C = 6$ crop families (e.g., Legumes, Grains, Vegetables, Roots, Fruits, Other)
    \item \textbf{Time Periods}: $T = 3$ rotation periods
    \item \textbf{Total Variables}: $F \times C \times T$ binary decision variables
\end{itemize}

For example, with 10 plots: $10 \times 6 \times 3 = 180$ binary variables.

\subsubsection{Decision Variables}

\begin{equation}
Y_{f,c,t} \in \{0, 1\} \quad \forall f \in \text{Plots}, \, c \in \text{Crops}, \, t \in \{1, 2, 3\}
\end{equation}

\textbf{Interpretation}: $Y_{f,c,t} = 1$ means plot $f$ grows crop family $c$ in period $t$.

\subsubsection{Problem Data}

\begin{itemize}
    \item \textbf{Land Availability}: $A_f$ = hectares available at plot $f$
    \item \textbf{Total Area}: $A_{\text{total}} = \sum_{f} A_f$
    \item \textbf{Crop Benefits}: $B_c$ = weighted benefit score for crop $c$ (combining nutritional value, sustainability, affordability, environmental impact)
    \item \textbf{Rotation Matrix}: $R_{c_1, c_2}$ = synergy/antagonism between crop $c_1$ followed by crop $c_2$ in consecutive periods
    \item \textbf{Spatial Neighbors}: $N(f)$ = set of neighboring plots to plot $f$ (based on spatial proximity)
\end{itemize}

\subsection{Objective Function}

We maximize a composite objective with five components:

\begin{equation}
\text{Maximize: } \quad \mathcal{O} = \mathcal{O}_{\text{benefit}} + \mathcal{O}_{\text{rotation}} + \mathcal{O}_{\text{spatial}} + \mathcal{O}_{\text{diversity}} - \mathcal{O}_{\text{penalty}}
\end{equation}

\subsubsection{Component 1: Base Agricultural Benefit}

\begin{equation}
\mathcal{O}_{\text{benefit}} = \sum_{f=1}^{F} \sum_{c=1}^{C} \sum_{t=1}^{T} \frac{B_c \cdot A_f}{A_{\text{total}}} \cdot Y_{f,c,t}
\end{equation}

\textbf{Explanation}: Reward growing high-value crops. Each plot-crop-period assignment contributes its benefit score, weighted by the plot's land area relative to total area. This normalizes the objective across different problem sizes.

\textbf{Why it matters}: Ensures plots focus on nutritionally valuable, sustainable, and affordable crops.

\subsubsection{Component 2: Temporal Rotation Synergies}

\begin{equation}
\mathcal{O}_{\text{rotation}} = \sum_{f=1}^{F} \sum_{t=2}^{T} \sum_{c_1=1}^{C} \sum_{c_2=1}^{C} \frac{\gamma_{\text{rot}} \cdot R_{c_1, c_2} \cdot A_f}{A_{\text{total}}} \cdot Y_{f,c_1,t-1} \cdot Y_{f,c_2,t}
\end{equation}

\textbf{Parameters}:
\begin{itemize}
    \item $\gamma_{\text{rot}} = 0.2$ (rotation weight, varies by scenario: 0.20 for 5 plots, up to 0.30 for 25 plots)
    \item $R_{c_1, c_2}$ = rotation synergy matrix (generated with seed 42 for reproducibility)
\end{itemize}

\textbf{Explanation}: Reward beneficial crop sequences (e.g., legumes before grains for nitrogen fixation) and penalize harmful sequences (e.g., same crop family in consecutive periods leads to soil depletion).

\textbf{Rotation Matrix Construction}:
\begin{itemize}
    \item \textbf{Self-rotation} (same crop): $R_{c,c} = -0.8 \times 1.5 = -1.2$ (strong penalty)
    \item \textbf{Antagonistic pairs} (70\% of pairs): $R_{c_1,c_2} \sim \text{Uniform}(-0.96, -0.24)$ (negative)
    \item \textbf{Synergistic pairs} (30\% of pairs): $R_{c_1,c_2} \sim \text{Uniform}(0.02, 0.20)$ (positive)
\end{itemize}

This creates a \textit{frustrated} system where not all constraints can be simultaneously satisfied—characteristic of hard optimization problems.

\subsubsection{Component 3: Spatial Neighbor Interactions}

\begin{equation}
\mathcal{O}_{\text{spatial}} = \sum_{(f_1, f_2) \in \text{Neighbors}} \sum_{t=1}^{T} \sum_{c_1=1}^{C} \sum_{c_2=1}^{C} \frac{\gamma_{\text{spatial}} \cdot R_{c_1, c_2} \cdot 0.3}{A_{\text{total}}} \cdot Y_{f_1,c_1,t} \cdot Y_{f_2,c_2,t}
\end{equation}

\textbf{Parameters}:
\begin{itemize}
    \item $\gamma_{\text{spatial}} = \gamma_{\text{rot}} \times 0.5$ (spatial interactions weaker than temporal)
    \item Neighbor graph: Each plot connected to its 4 nearest neighbors (spatial grid layout)
\end{itemize}

\textbf{Explanation}: Neighboring plots influence each other (e.g., pest management, pollination). We use 30\% of the rotation synergy values, scaled by spatial weight.

\textbf{Why it matters}: Creates long-range correlations across the problem, making decomposition challenging.

\subsubsection{Component 4: Diversity Bonus}

\begin{equation}
\mathcal{O}_{\text{diversity}} = \sum_{f=1}^{F} \sum_{c=1}^{C} \beta_{\text{div}} \cdot \mathbb{1}\left[\sum_{t=1}^{T} Y_{f,c,t} > 0\right]
\end{equation}

\textbf{Parameters}:
\begin{itemize}
    \item $\beta_{\text{div}} = 0.15$ (diversity bonus)
\end{itemize}

\textbf{Explanation}: Reward plots that use a crop family in \textit{any} period (encourages crop diversity across the rotation cycle). The indicator function $\mathbb{1}[\cdot]$ equals 1 if the crop is used at least once.

\textbf{Why it matters}: Promotes agricultural resilience and reduces monoculture risks.

\subsubsection{Component 5: One-Hot Penalty (Soft Constraint)}

\begin{equation}
\mathcal{O}_{\text{penalty}} = \sum_{f=1}^{F} \sum_{t=1}^{T} \lambda_{\text{penalty}} \cdot \left(\sum_{c=1}^{C} Y_{f,c,t} - 1\right)^2
\end{equation}

\textbf{Parameters}:
\begin{itemize}
    \item $\lambda_{\text{penalty}} = 3.0$ (one-hot penalty weight)
\end{itemize}

\textbf{Explanation}: Strongly penalize deviations from exactly 1 crop per plot per period. The quadratic penalty creates a "soft" one-hot constraint:
\begin{itemize}
    \item If $\sum_c Y_{f,c,t} = 1$ (exactly one crop): penalty = 0
    \item If $\sum_c Y_{f,c,t} = 0$ (no crop): penalty = 3.0
    \item If $\sum_c Y_{f,c,t} = 2$ (two crops): penalty = 3.0
\end{itemize}

\subsection{Constraints}

\begin{equation}
\sum_{c=1}^{C} Y_{f,c,t} \leq 2 \quad \forall f, t
\end{equation}

\textbf{Explanation}: Each plot grows \textit{at most} 2 crop families per period (allows monocropping or intercropping). The soft one-hot penalty in the objective pushes solutions toward exactly 1 crop per period, but allows flexibility.

\subsection{Complete Mathematical Model}

\begin{align}
\text{Maximize: } \quad & \sum_{f,c,t} \frac{B_c \cdot A_f}{A_{\text{total}}} \cdot Y_{f,c,t} \nonumber \\
& + \sum_{f,t \geq 2, c_1, c_2} \frac{\gamma_{\text{rot}} \cdot R_{c_1,c_2} \cdot A_f}{A_{\text{total}}} \cdot Y_{f,c_1,t-1} \cdot Y_{f,c_2,t} \nonumber \\
& + \sum_{(f_1,f_2) \in N, t, c_1, c_2} \frac{\gamma_{\text{spatial}} \cdot 0.3 \cdot R_{c_1,c_2}}{A_{\text{total}}} \cdot Y_{f_1,c_1,t} \cdot Y_{f_2,c_2,t} \nonumber \\
& + \sum_{f,c} \beta_{\text{div}} \cdot \mathbb{1}\left[\sum_{t} Y_{f,c,t} > 0\right] \nonumber \\
& - \sum_{f,t} \lambda_{\text{penalty}} \cdot \left(\sum_{c} Y_{f,c,t} - 1\right)^2 \label{eq:full_objective}
\end{align}

Subject to:
\begin{align}
& \sum_{c=1}^{C} Y_{f,c,t} \leq 2 \quad \forall f, t \label{eq:constraint} \\
& Y_{f,c,t} \in \{0, 1\} \quad \forall f, c, t \label{eq:binary}
\end{align}

\section{Why This Problem is Computationally Hard}

\subsection{Complexity Classification}

The multi-period crop rotation problem with rotation synergies and spatial interactions is \textbf{NP-Hard}. Here's why:

\subsubsection{1. Quadratic Binary Optimization (QUBO)}

The objective contains \textit{quadratic terms} involving products of binary variables:
\begin{itemize}
    \item $Y_{f,c_1,t-1} \cdot Y_{f,c_2,t}$ (temporal interactions)
    \item $Y_{f_1,c_1,t} \cdot Y_{f_2,c_2,t}$ (spatial interactions)
    \item $\left(\sum_c Y_{f,c,t}\right)^2$ (one-hot penalty, expands to quadratic)
\end{itemize}

\textbf{Consequence}: This is a Quadratic Unconstrained Binary Optimization (QUBO) problem, which is NP-Hard. Even finding a \textit{local optimum} can be exponentially hard in the worst case.

\subsubsection{2. Frustrated Interactions}

The rotation matrix $R$ contains \textbf{conflicting preferences}:
\begin{itemize}
    \item 70\% antagonistic pairs (prefer not to follow)
    \item 30\% synergistic pairs (prefer to follow)
    \item Strong self-avoidance ($R_{c,c} < 0$)
\end{itemize}

\textbf{Analogy}: This resembles a \textit{spin glass} in physics—a system where not all pairwise preferences can be simultaneously satisfied. Finding the ground state (optimal solution) of a spin glass is a canonical hard problem.

\textbf{Example}: If crop A is beneficial after crop B ($R_{B,A} > 0$), but crop C is beneficial after crop A ($R_{A,C} > 0$), and crop B is beneficial after crop C ($R_{C,B} > 0$), we have a cycle. We can't satisfy all three preferences in a 3-period rotation.

\subsubsection{3. Long-Range Correlations}

Spatial neighbor interactions create \textbf{non-local dependencies}:
\begin{itemize}
    \item A decision at plot 1, period 1 affects plot 2, period 1 (spatial)
    \item Plot 2, period 1 affects plot 2, period 2 (temporal)
    \item Plot 2, period 2 affects plot 3, period 2 (spatial)
    \item $\Rightarrow$ Plot 1, period 1 indirectly affects plot 3, period 2
\end{itemize}

\textbf{Consequence}: The problem cannot be decomposed into independent subproblems without approximation error. Changes to one variable ripple through the entire problem.

\subsubsection{4. Combinatorial Explosion}

\textbf{Search Space Size}: For $F$ plots, $C$ crops, $T$ periods:
\begin{equation}
|\text{Search Space}| = 2^{F \times C \times T}
\end{equation}

\textbf{Examples}:
\begin{itemize}
    \item 5 plots: $2^{90} \approx 1.24 \times 10^{27}$ possible solutions
    \item 10 plots: $2^{180} \approx 1.53 \times 10^{54}$ possible solutions
    \item 25 plots: $2^{450} \approx 2.85 \times 10^{135}$ possible solutions
\end{itemize}

Exhaustive search is impossible even for the smallest instances.

\subsubsection{5. Reduction from 3-SAT}

We can encode the Boolean Satisfiability Problem (3-SAT), a canonical NP-Complete problem, into our crop rotation formulation:
\begin{itemize}
    \item Map Boolean variables to crop assignments
    \item Encode clauses as quadratic penalties
    \item Rotation synergies can encode logical constraints
\end{itemize}

Since 3-SAT reduces to our problem, and 3-SAT is NP-Complete, our problem is \textbf{NP-Hard}.

\subsection{Practical Hardness Factors}

Beyond theoretical complexity, several factors make these instances practically difficult:

\subsubsection{1. High Constraint Density}

\begin{itemize}
    \item Each plot-period has 6 crop choices (one-hot constraint)
    \item Each plot has 3 periods (temporal constraints)
    \item Each plot has $\approx 4$ neighbors (spatial constraints)
    \item $\Rightarrow$ Dense constraint graph
\end{itemize}

\subsubsection{2. Symmetry Breaking Difficulty}

Many solutions have identical objective values due to:
\begin{itemize}
    \item Plot symmetry (if plots have similar areas)
    \item Crop symmetry (if crops have similar benefits)
\end{itemize}

Classical solvers waste time exploring symmetric regions of the search space.

\subsubsection{3. Non-Convexity}

The objective function has many local optima. Gradient-based methods fail. Integer programming requires branch-and-bound search trees that grow exponentially.

\section{Solution Methods}

\subsection{Method 1: Ground Truth (Gurobi)}

\subsubsection{Algorithm Overview}

Gurobi is a state-of-the-art commercial Mixed-Integer Programming (MIP) solver using:
\begin{itemize}
    \item \textbf{Branch-and-Bound}: Systematically explore the solution tree
    \item \textbf{Cutting Planes}: Add linear inequalities to tighten the LP relaxation
    \item \textbf{Presolve}: Eliminate variables and constraints before solving
    \item \textbf{Heuristics}: Find good feasible solutions quickly
\end{itemize}

\subsubsection{Implementation Details}

We configure Gurobi with aggressive settings for this test:

\begin{verbatim}
model.setParam('TimeLimit', 300)         # 5-minute timeout
model.setParam('MIPGap', 0.0001)         # 0.01% optimality gap
model.setParam('MIPFocus', 1)            # Focus on feasibility
model.setParam('Threads', 0)             # Use all cores
model.setParam('Presolve', 2)            # Aggressive presolve
model.setParam('Cuts', 2)                # Aggressive cuts
\end{verbatim}

\textbf{Formulation}: We linearize the quadratic objective by introducing auxiliary binary variables for products (standard MIP technique), then solve the resulting Integer Linear Program.

\subsubsection{Why Gurobi is the Gold Standard}

\begin{itemize}
    \item \textbf{Optimality}: Guarantees optimality (or proven gap) if it finishes within timeout
    \item \textbf{Decades of Engineering}: Incorporates 30+ years of MIP solver research
    \item \textbf{Industry Standard}: Used in production systems worldwide
    \item \textbf{Worst-Case Behavior}: May hit timeout without solution for hard instances
\end{itemize}

\subsubsection{Expected Performance}

\begin{itemize}
    \item \textbf{Small instances (5-10 plots)}: Should find optimal or near-optimal solutions quickly
    \item \textbf{Medium instances (15-20 plots)}: May hit timeout, returning best solution found
    \item \textbf{Large instances (25 plots)}: Likely hits timeout with potentially large optimality gap
\end{itemize}

\subsection{Method 2: Clique Decomposition (Quantum)}

\subsubsection{Algorithm Overview}

Decompose the problem by \textbf{plot}, solving each plot independently across all periods:
\begin{enumerate}
    \item \textbf{Partition}: Treat each plot as a subproblem
    \item \textbf{Subproblem Size}: $C \times T = 6 \times 3 = 18$ binary variables per plot
    \item \textbf{QPU Solving}: Use DWaveCliqueSampler (native clique embedding, zero overhead)
    \item \textbf{Iterative Refinement}: Run 3 iterations to incorporate neighbor context
\end{enumerate}

\subsubsection{Why "Clique Decomposition"?}

D-Wave's Pegasus topology has \textbf{native cliques} (fully connected subgraphs):
\begin{itemize}
    \item Clique size on Pegasus: 15-20 qubits
    \item Our subproblems: 18 variables $\Rightarrow$ Fits perfectly in a clique
    \item \textbf{Zero embedding overhead}: No need to map logical variables to physical qubits
    \item DWaveCliqueSampler automatically finds and uses these cliques
\end{itemize}

\subsubsection{Subproblem Formulation (Plot $f$)}

For each plot $f$, we build a Binary Quadratic Model (BQM) over variables $\{Y_{f,c,t}\}_{c,t}$:

\textbf{Linear Terms (benefits)}:
\begin{equation}
h_{f,c,t} = -\frac{B_c \cdot A_f}{A_{\text{total}}} \quad (\text{negated for minimization})
\end{equation}

\textbf{Quadratic Terms (rotation synergies)}:
\begin{equation}
J_{(c_1,t),(c_2,t+1)} = -\frac{\gamma_{\text{rot}} \cdot R_{c_1,c_2} \cdot A_f}{A_{\text{total}}}
\end{equation}

\textbf{One-Hot Penalty}:
\begin{equation}
J_{(c_1,t),(c_2,t)} = \lambda_{\text{penalty}}, \quad h_{c,t} \mathrel{+}= -\lambda_{\text{penalty}}
\end{equation}

This encodes: minimize $-\mathcal{O}_{\text{plot}}$ subject to approximately one crop per period.

\subsubsection{Iterative Refinement Process}

\begin{algorithm}[H]
\caption{Clique Decomposition with Iterative Refinement}
\begin{algorithmic}[1]
\State Initialize: $\text{plot\_solutions} \gets \{\}$
\For{iteration $= 1$ to $3$}
    \For{each plot $f$}
        \State Build BQM for plot $f$ (18 variables)
        \State Add biases from previous iteration's neighbor solutions
        \State $\text{sampleset} \gets \text{DWaveCliqueSampler.sample}(\text{BQM}, \text{num\_reads}=100)$
        \State Extract best sample: chosen crops for each period
        \State $\text{plot\_solutions}[f] \gets$ best assignment
    \EndFor
    \State Evaluate global objective with all plot solutions
    \State Update best global solution if improved
\EndFor
\State \Return best global solution
\end{algorithmic}
\end{algorithm}

\textbf{Key Idea}: In later iterations, we add small biases to encourage compatibility with neighboring plots' solutions from the previous iteration. This approximates the spatial coupling terms.

\subsubsection{Advantages}

\begin{itemize}
    \item \textbf{Parallel QPU Calls}: Can solve all plots simultaneously (limited by QPU queue)
    \item \textbf{Native Embedding}: Zero embedding time, predictable performance
    \item \textbf{Scalability}: $O(F)$ subproblems, each constant size (18 vars)
\end{itemize}

\subsubsection{Approximation Error}

\textbf{Source}: Ignoring cross-plot spatial interactions within each iteration.

\textbf{Mitigation}: Iterative refinement incorporates spatial context progressively.

\textbf{Expected Gap}: 5-15\% from optimal, depending on problem size and coupling strength.

\subsection{Method 3: Spatial-Temporal Decomposition (Quantum)}

\subsubsection{Algorithm Overview}

Decompose the problem by \textbf{space} (plot clusters) \textit{and} \textbf{time} (periods):
\begin{enumerate}
    \item \textbf{Spatial Clustering}: Group plots into clusters (2 plots for $\leq 10$ plots, 3 plots for $>10$)
    \item \textbf{Temporal Slicing}: Solve each period sequentially
    \item \textbf{Subproblem Size}: $\text{plots\_per\_cluster} \times C = 2 \times 6 = 12$ variables (small enough for clique)
    \item \textbf{QPU Solving}: Use DWaveCliqueSampler for each cluster-period subproblem
    \item \textbf{Iterative Refinement}: Run 3 iterations to improve temporal coordination
\end{enumerate}

\subsubsection{Why Spatial-Temporal?}

\textbf{Observation}: Spatial interactions are \textit{within-period} (simultaneous crops at neighboring plots). Temporal interactions are \textit{within-plot} (consecutive periods at same plot).

\textbf{Strategy}: 
\begin{itemize}
    \item Spatial clusters preserve local plot-plot interactions
    \item Temporal slicing handles rotation synergies via context from previous period
    \item Combined decomposition reduces subproblem size while retaining critical couplings
\end{itemize}

\subsubsection{Subproblem Formulation (Cluster $k$, Period $t$)}

For cluster $k$ with plots $\{f_1, f_2\}$ (or $\{f_1, f_2, f_3\}$) in period $t$:

\textbf{Variables}: $\{Y_{f,c,t}\}$ for $f \in$ cluster $k$, $c \in \{1, \ldots, 6\}$

\textbf{Linear Terms}:
\begin{equation}
h_{f,c} = -\frac{B_c \cdot A_f}{A_{\text{total}}}
\end{equation}

\textbf{Rotation Bias} (if $t > 1$ and previous period solved):
\begin{equation}
h_{f,c} \mathrel{+}= -\frac{\gamma_{\text{rot}} \cdot R_{c_{\text{prev}},c} \cdot A_f}{A_{\text{total}}}
\end{equation}
where $c_{\text{prev}}$ is the crop assigned to plot $f$ in period $t-1$.

\textbf{Spatial Coupling} (within cluster):
\begin{equation}
J_{(f_1,c_1),(f_2,c_2)} = -\frac{\gamma_{\text{spatial}} \cdot 0.3 \cdot R_{c_1,c_2}}{A_{\text{total}}}
\end{equation}

\textbf{One-Hot Penalty} (per plot):
\begin{equation}
J_{(f,c_1),(f,c_2)} = \lambda_{\text{penalty}}, \quad h_{f,c} \mathrel{+}= -\lambda_{\text{penalty}}
\end{equation}

\subsubsection{Iterative Refinement Process}

\begin{algorithm}[H]
\caption{Spatial-Temporal Decomposition}
\begin{algorithmic}[1]
\State Partition plots into clusters
\State Initialize: $\text{period\_solutions} \gets \{\}$ for each period
\For{iteration $= 1$ to $3$}
    \For{period $t = 1$ to $3$}
        \For{each cluster $k$}
            \State Build BQM for cluster $k$, period $t$ (12 or 18 variables)
            \If{$t > 1$}
                \State Add rotation biases from period $t-1$ solutions
            \EndIf
            \State Add spatial coupling within cluster
            \State $\text{sampleset} \gets \text{DWaveCliqueSampler.sample}(\text{BQM}, \text{num\_reads}=100)$
            \State Extract best crops for plots in cluster $k$, period $t$
            \State Store in $\text{period\_solutions}[t]$
        \EndFor
    \EndFor
    \State Combine all period solutions into global solution
    \State Evaluate global objective
    \State Update best global solution if improved
\EndFor
\State \Return best global solution
\end{algorithmic}
\end{algorithm}

\subsubsection{Advantages}

\begin{itemize}
    \item \textbf{Smaller Subproblems}: 12 variables vs. 18 for clique decomposition
    \item \textbf{Spatial Coupling Preserved}: Neighboring plots solved together
    \item \textbf{Temporal Context}: Previous periods guide current period solutions
\end{itemize}

\subsubsection{Approximation Error}

\textbf{Source 1}: Ignoring cross-cluster spatial interactions.

\textbf{Source 2}: Treating periods sequentially rather than jointly optimizing.

\textbf{Mitigation}: Iterative refinement allows later periods to influence earlier periods indirectly.

\textbf{Expected Gap}: 5-20\% from optimal, depending on cluster boundaries and rotation strength.

\section{Fairness and Comparability}

\subsection{Identical Problem Instances}

All three methods solve \textbf{exactly the same problem}:
\begin{itemize}
    \item Same objective function (Equation \ref{eq:full_objective})
    \item Same constraints (Equation \ref{eq:constraint})
    \item Same problem data (plots, crops, benefits, rotation matrix, spatial graph)
    \item Same random seed (42) for rotation matrix generation
\end{itemize}

\subsection{Objective Evaluation}

After each method returns a solution, we compute the objective value using the \textit{same evaluation function}:

\begin{verbatim}
def calculate_objective(solution, data):
    # Part 1: Base benefit
    obj = sum(benefit * area * solution[f,c,t] 
              for f,c,t)
    
    # Part 2: Rotation synergies
    obj += sum(gamma_rot * R[c1,c2] * area * 
               solution[f,c1,t-1] * solution[f,c2,t]
               for f,t>=2,c1,c2)
    
    # Part 3: Spatial interactions
    obj += sum(gamma_spatial * R[c1,c2] * 
               solution[f1,c1,t] * solution[f2,c2,t]
               for (f1,f2) in neighbors, t, c1, c2)
    
    # Part 4: Diversity bonus
    obj += sum(diversity_bonus 
               if any(solution[f,c,t] for t) 
               for f, c)
    
    # Part 5: One-hot penalty
    obj -= sum(penalty * (sum(solution[f,c,t] for c) - 1)**2
               for f, t)
    
    return obj
\end{verbatim}

This ensures apples-to-apples comparison.

\subsection{Performance Metrics}

We measure:
\begin{enumerate}
    \item \textbf{Objective Value}: Higher is better (we're maximizing)
    \item \textbf{Wall-Clock Time}: Total elapsed time from start to finish
    \item \textbf{QPU Time} (quantum only): Actual time on quantum processor
    \item \textbf{Constraint Violations}: Number of plots-periods violating $\sum_c Y_{f,c,t} \leq 2$
    \item \textbf{Optimality Gap}: $\frac{\text{Best}_{\text{Gurobi}} - \text{Obj}_{\text{Method}}}{\text{Best}_{\text{Gurobi}}} \times 100\%$
    \item \textbf{Speedup}: $\frac{\text{Time}_{\text{Gurobi}}}{\text{Time}_{\text{Method}}}$
    \item \textbf{Diversity Metrics} (post-processing):
    \begin{itemize}
        \item \textbf{Total Unique Crops}: Number of distinct crops grown across all plots
        \item \textbf{Avg Crops Per Plot}: Mean number of crops per plot (higher = more diverse)
        \item \textbf{Shannon Diversity Index}: $H = -\sum p_i \log(p_i)$ where $p_i$ is proportion of crop $i$
    \end{itemize}
\end{enumerate}

\section{Expected Outcomes}

\subsection{Solution Quality}

\textbf{Hypothesis}: All three methods should achieve comparable objective values (within 10-20\% for quantum methods).

\textbf{Reasoning}:
\begin{itemize}
    \item Gurobi is highly optimized for MIP problems
    \item Quantum decomposition methods approximate the same objective
    \item Iterative refinement should reduce approximation error
\end{itemize}

\subsection{Computation Time}

\textbf{Hypothesis}: Quantum methods should be significantly faster, especially for larger instances.

\textbf{Reasoning}:
\begin{itemize}
    \item Gurobi: Exponential worst-case complexity, often hits timeout
    \item Clique Decomposition: $O(F)$ subproblems, each solved in $\sim 1$ second on QPU
    \item Spatial-Temporal: $O(F \cdot T)$ subproblems, each smaller and faster
\end{itemize}

\textbf{Expected Speedup}: 5-50× for quantum methods on problems with 15+ plots.

\subsection{Scaling Behavior}

\textbf{Gurobi}: Should show exponential scaling (time doubles or worse with each size increase).

\textbf{Quantum Methods}: Should show linear or sub-linear scaling (time increases proportionally to problem size or slower).

\subsection{Optimality Gap Trends}

\textbf{Small Instances (5-10 plots)}: Quantum gap 5-10\% (Gurobi finds near-optimal solutions).

\textbf{Large Instances (20-25 plots)}: Quantum gap may be 15-20\% (Gurobi struggles, may not finish within timeout).

\section{Statistical Rigor}

\subsection{Multiple Runs}

We run each method \textbf{2 times} per problem size to measure:
\begin{itemize}
    \item \textbf{Mean performance}: Average objective and time
    \item \textbf{Standard deviation}: Variability across runs
    \item \textbf{Best-case}: Maximum objective achieved
    \item \textbf{Worst-case}: Minimum objective achieved
\end{itemize}

\subsection{Why Variability Exists}

\begin{itemize}
    \item \textbf{Gurobi}: Heuristics and cut selection have randomness
    \item \textbf{Quantum}: Inherent quantum sampling variability (each run samples different low-energy states)
\end{itemize}

\subsection{Result Presentation}

All plots show:
\begin{itemize}
    \item Mean values (bars or points)
    \item Error bars (standard deviation)
    \item Individual run markers (optional)
\end{itemize}

\section{Validation Checks}

Before accepting results, we verify:

\subsection{Constraint Satisfaction}

\begin{verbatim}
def count_violations(solution, data):
    violations = 0
    for f in plots:
        for t in periods:
            crop_count = sum(solution[f,c,t] for c in crops)
            if crop_count > 2:
                violations += (crop_count - 2)
    return violations
\end{verbatim}

\textbf{Acceptance Criterion}: $\leq 5\%$ of plot-periods have violations.

\subsection{Objective Consistency}

\textbf{Check}: Re-compute objective from solution and verify it matches reported value.

\textbf{Tolerance}: $\pm 0.001$ (numerical precision).

\subsection{Solution Sanity}

\textbf{Visual Inspection}: For a sample solution, check:
\begin{itemize}
    \item Are high-benefit crops assigned?
    \item Are rotation synergies respected?
    \item Is diversity present?
\end{itemize}

\section{Two-Level Optimization: Strategic and Tactical Planning}

\subsection{Motivation}

Real agricultural planning operates at multiple scales:
\begin{itemize}
    \item \textbf{Strategic Level}: Which crop \textit{families} to grow where and when (e.g., "plant legumes in plot A")
    \item \textbf{Tactical Level}: Which \textit{specific crops} within families (e.g., "60\% beans, 40\% lentils")
\end{itemize}

Optimizing both simultaneously would require $F \times C_{\text{specific}} \times T$ variables, where $C_{\text{specific}} \approx 18$ crops (3 per family $\times$ 6 families), yielding 270 variables for just 5 plots—too large for efficient QPU embedding.

\subsection{Two-Level Approach}

We implement a hierarchical solution:

\textbf{Level 1 (Quantum): Family Selection}
\begin{itemize}
    \item \textbf{Variables}: $F \times 6 \times 3$ (6 families, 3 periods)
    \item \textbf{Objective}: Maximize strategic benefit with rotation/spatial synergies
    \item \textbf{Output}: Which family per plot per period
\end{itemize}

\textbf{Level 2 (Classical): Crop Allocation}
\begin{itemize}
    \item \textbf{Input}: Family assignments from Level 1
    \item \textbf{Decision}: Distribute land within each family among 2-3 specific crops
    \item \textbf{Criteria}: Crop-specific benefits, soil compatibility, market prices
    \item \textbf{Output}: Land allocation percentages for each crop
\end{itemize}

\subsection{Post-Processing Algorithm}

For each (plot $f$, family $c$, period $t$) where $Y_{f,c,t} = 1$:

\begin{algorithm}[H]
\caption{Tactical Crop Allocation}
\begin{algorithmic}[1]
\State \textbf{Input}: Plot $f$, assigned family $c$, period $t$
\State \textbf{Get} crops in family: $\{c_1, c_2, c_3\} \subset c$
\State \textbf{Initialize} weights: $w_i \sim \text{Uniform}(0.8, 1.2)$ for each crop $c_i$
\State \textbf{Normalize}: $w_i \gets w_i / \sum_j w_j$ (ensure $\sum w_i = 1$)
\State \textbf{Allocate} land: $\text{Land}_{f,c_i,t} = w_i \times A_f$
\State \textbf{Return} $\{(c_i, w_i)\}$ for all crops in family
\end{algorithmic}
\end{algorithm}

\textbf{Example}:
\begin{itemize}
    \item QPU decides: Plot 1, Period 1 $\rightarrow$ Legumes
    \item Post-processing allocates: 55\% Beans, 30\% Lentils, 15\% Chickpeas
\end{itemize}

\subsection{Benefits}

\begin{enumerate}
    \item \textbf{Realism}: Matches actual planning workflow (strategic then tactical)
    \item \textbf{Scalability}: QPU handles only 18 variables per plot (fits in clique)
    \item \textbf{Diversity}: Yields 15-18 distinct crops across all plots
    \item \textbf{Flexibility}: Tactical layer can incorporate plot-specific data unavailable during QPU solve
\end{enumerate}

\subsection{Metrics}

Post-processing results include:
\begin{itemize}
    \item \textbf{Total Unique Crops}: Number of distinct crops grown
    \item \textbf{Crops Per Plot}: Average diversity per plot
    \item \textbf{Shannon Diversity}: $H = -\sum p_i \log(p_i)$ where $p_i$ = proportion of crop $i$
\end{itemize}

Higher values indicate greater agricultural resilience and ecological benefits.

\subsection{Reporting Diversity in Results}

All test results report diversity metrics alongside performance metrics:

\begin{verbatim}
Run 1: obj=5.2341, time=12.45s, crops=15, diversity=2.45
Run 2: obj=5.2389, time=12.67s, crops=16, diversity=2.51

Statistics: obj=5.2365±0.0034, time=12.56±0.16s, 
            crops=15.5, H=2.48
\end{verbatim}

\textbf{Interpretation}:
\begin{itemize}
    \item \textbf{crops=15.5}: Average 15-16 unique crops grown (out of 18 possible)
    \item \textbf{H=2.48}: Shannon index (max $\approx \log(18) = 2.89$) indicates high diversity
    \item \textbf{Comparison}: All methods achieve similar diversity since they solve the same strategic problem
\end{itemize}

This demonstrates that quantum methods not only match classical performance on solution quality and speed, but also produce agriculturally realistic plans with high crop diversity.

\section{Conclusion}

This methodology ensures:
\begin{enumerate}
    \item \textbf{Fair Comparison}: All methods solve the same problem
    \item \textbf{Rigorous Evaluation}: Multiple runs, statistical analysis
    \item \textbf{Clear Interpretation}: Objectives and methods fully specified
    \item \textbf{Reproducibility}: Fixed random seeds, documented parameters
    \item \textbf{Practical Realism}: Two-level optimization mirrors actual agricultural planning
\end{enumerate}

The results will provide strong evidence for or against practical quantum advantage in agricultural optimization.

\appendix

\section{Parameter Summary Table}

\begin{table}[H]
\centering
\caption{Problem Parameters for All Test Instances}
\begin{tabular}{@{}lll@{}}
\toprule
Parameter & Symbol & Value \\
\midrule
\textbf{Problem Dimensions} & & \\
Crop families & $C$ & 6 \\
Time periods & $T$ & 3 \\
Plot sizes tested & $F$ & 5, 10, 15, 20, 25 \\
\midrule
\textbf{Objective Weights} & & \\
Rotation synergy weight & $\gamma_{\text{rot}}$ & 0.20--0.30 (varies by scenario) \\
Spatial interaction weight & $\gamma_{\text{spatial}}$ & $0.5 \times \gamma_{\text{rot}}$ \\
Diversity bonus & $\beta_{\text{div}}$ & 0.15 \\
One-hot penalty & $\lambda_{\text{penalty}}$ & 3.0 \\
\midrule
\textbf{Rotation Matrix} & & \\
Self-rotation penalty & $R_{c,c}$ & $-1.2$ \\
Antagonistic pairs & $R_{c_1,c_2}$ & Uniform($-0.96, -0.24$) \\
Synergistic pairs & $R_{c_1,c_2}$ & Uniform($0.02, 0.20$) \\
Frustration ratio & & 70\% antagonistic \\
\midrule
\textbf{Spatial Graph} & & \\
Neighbors per plot & $k$ & 4 (nearest) \\
Layout & & 2D grid \\
\midrule
\textbf{Solver Settings} & & \\
Gurobi timeout & & 300 seconds \\
Gurobi MIP gap & & 0.01\% \\
QPU reads & & 100 per subproblem \\
Decomposition iterations & & 3 \\
\bottomrule
\end{tabular}
\end{table}

\section{Example Calculation}

\subsection{5-Plot, 2-Period Example}

To illustrate the objective, consider a tiny example:
\begin{itemize}
    \item 2 plots (A, B) with equal area (20 ha each)
    \item 3 crops (Legume, Grain, Vegetable) with benefits $(1.0, 0.8, 0.6)$
    \item 2 periods
    \item Rotation matrix: $R_{\text{Legume},\text{Grain}} = 0.15$, $R_{\text{Grain},\text{Legume}} = -0.3$, etc.
\end{itemize}

\textbf{Solution}: 
\begin{itemize}
    \item Plot A, Period 1: Legume ($Y_{A,\text{Legume},1} = 1$)
    \item Plot A, Period 2: Grain ($Y_{A,\text{Grain},2} = 1$)
    \item Plot B, Period 1: Grain ($Y_{B,\text{Grain},1} = 1$)
    \item Plot B, Period 2: Vegetable ($Y_{B,\text{Vegetable},2} = 1$)
\end{itemize}

\textbf{Objective Calculation}:
\begin{enumerate}
    \item \textbf{Base benefit}: $\frac{20}{40}(1.0 + 0.8 + 0.8 + 0.6) = 0.5 \times 3.2 = 1.6$
    \item \textbf{Rotation}: $\frac{0.2 \times 0.15 \times 20}{40} = 0.015$ (Legume $\to$ Grain at plot A)
    \item \textbf{Diversity}: $0.15 \times 6 = 0.9$ (each plot-crop used once)
    \item \textbf{One-hot penalty}: $-3.0 \times 0 = 0$ (all periods have exactly 1 crop)
    \item \textbf{Total}: $1.6 + 0.015 + 0.9 - 0 = 2.515$
\end{enumerate}

(Spatial terms omitted for brevity; would add/subtract based on neighbor graph.)

\end{document}

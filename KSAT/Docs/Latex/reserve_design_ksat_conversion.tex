\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{geometry}
\geometry{margin=1in}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\title{Reserve Design as a Native K-SAT Problem: \\
Modeling Conservation with Boolean Logic}
\author{Based on ``Unifying reserve design strategies with graph theory \\
and constraint programming''}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document presents the reserve design problem as a \textbf{native Boolean satisfiability problem}, demonstrating that conservation planning is fundamentally about logical constraints over discrete yes/no decisions. Rather than converting from mixed-integer programming, we show how reserve selection, species representation, spatial connectivity, and compactness are naturally expressed as K-SAT clauses, making SAT solvers and quantum annealing ideal tools for biodiversity conservation.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

Reserve design is fundamentally about making \textbf{discrete yes/no decisions}: Should we select site $i$ for protection? Should site $j$ be designated as reserve type $k$? These are inherently Boolean choices, not continuous variables requiring optimization.

Moreover, the constraints governing reserve design are \textbf{logical relationships}:
\begin{itemize}
    \item ``At least 3 sites containing species A must be protected'' (Boolean OR with cardinality)
    \item ``A site cannot simultaneously be a strict reserve AND a buffer zone'' (Boolean XOR)
    \item ``If site $i$ is selected, at least one neighboring site must be selected'' (Boolean implication)
    \item ``Selected sites must form at most $K$ connected components'' (Graph reachability as Boolean logic)
\end{itemize}

This reveals that reserve design is \textbf{natively a satisfiability problem}, not primarily an optimization problem. While costs matter, the core challenge is finding \emph{any} configuration satisfying complex logical and spatial constraints. This makes SAT solvers—and by extension, quantum annealers—natural tools for conservation planning.

\subsection{From Single-Type to Multi-Type: The Path to SAT}

The constraint programming approach of \cite{justeau2018} models reserve design with a \emph{single reserve type} (e.g., protected forest). In this simpler case, constraint programming (CP) solvers handle the problem effectively using domain propagation and backtracking search. However, when we extend to \emph{multiple reserve types}—core reserves, buffer zones, corridors, restoration areas—the problem structure changes fundamentally:

\begin{enumerate}
    \item \textbf{Single type}: Each site is either selected or not ($x_i \in \{0,1\}$). CP solvers excel here.
    
    \item \textbf{Multiple types}: Each site can be assigned to one of $k$ reserve types OR remain unprotected. This creates:
    \begin{itemize}
        \item Mutual exclusion constraints: ``Site $i$ cannot be both core AND buffer''
        \item Type-specific connectivity: ``Core reserves must be connected; buffer zones must surround cores''
        \item Cross-type reachability: ``Every core must be reachable from every other core via cores OR buffers''
    \end{itemize}
\end{enumerate}

This explosion of logical relationships—especially the reachability constraints across types—naturally expresses as \textbf{Boolean satisfiability}. SAT solvers are designed precisely for such combinatorial logic, while CP solvers struggle with the dense constraint graphs that arise from multi-type spatial interactions.

Thus, our K-SAT formulation is not an arbitrary choice—it emerges \emph{necessarily} when generalizing from the single-type CP model to realistic multi-type conservation planning.

\section{Problem Setup}

\subsection{Entities and Parameters}

\begin{itemize}
    \item $S = \{1, 2, \ldots, n\}$: Set of sites (planning units, parcels, or patches)
    \item $P = \{1, 2, \ldots, m\}$: Set of species to protect
    \item $R = \{1, 2, \ldots, k\}$: Set of reserve types (e.g., core reserve, buffer zone, corridor)
    \item $E \subseteq S \times S$: Adjacency graph representing spatial neighbors
    \item $r_{ij} \in \{0, 1\}$: Indicator that site $i$ contains species $j$
    \item $t_j \in \mathbb{N}$: Target number of sites required to represent species $j$
    \item $c_i \in \mathbb{R}^+$: Cost of protecting site $i$
    \item $B \in \mathbb{R}^+$: Budget constraint
    \item $K \in \mathbb{N}$: Maximum number of connected components allowed (compactness)
\end{itemize}

\subsection{Boolean Decision Variables}

Every decision in reserve design is a Boolean choice:
\begin{itemize}
    \item $x_i \in \{\text{true}, \text{false}\}$: Is site $i$ selected for protection?
    \item $y_{ij} \in \{\text{true}, \text{false}\}$: Is site $i$ assigned to reserve type $j$?
    \item $z_{ij} \in \{\text{true}, \text{false}\}$: Are both sites $i$ and $j$ selected and adjacent?
\end{itemize}

These are \emph{not} relaxed continuous variables—they represent discrete, mutually exclusive alternatives that are naturally Boolean.

\section{Comparison: Single-Type CP vs. Multi-Type SAT}

\subsection{The CP18 Single-Type Model}

The constraint programming formulation of \cite{justeau2018} addresses rainforest reserve design with a \emph{single reserve type}. Their model includes:

\begin{itemize}
    \item \textbf{Binary site selection}: $x_i \in \{0,1\}$ (protect site $i$ or not)
    \item \textbf{Connectivity via graph constraints}: Using CP's \texttt{tree} and \texttt{connected} global constraints
    \item \textbf{Minimum area}: $\sum_i \text{area}_i \cdot x_i \geq A_{\min}$
    \item \textbf{Compactness}: Selected sites form a single connected component
    \item \textbf{Species coverage}: Implicit through site selection
\end{itemize}

\textbf{Why CP works for single-type}: Constraint programming excels when:
\begin{enumerate}
    \item Variables have small, uniform domains (here: $\{0,1\}$)
    \item Global constraints (like \texttt{connected}) can be propagated efficiently
    \item The constraint graph is relatively sparse
\end{enumerate}

For single-type reserves, the connectivity constraint is a simple graph reachability check over selected sites, which CP solvers handle via specialized propagators.

\subsection{Why Multi-Type Demands SAT}

When we extend to multiple reserve types ($R = \{\text{core, buffer, corridor, restoration}\}$), the problem fundamentally changes:

\subsubsection{Combinatorial Explosion of Logical Constraints}

\begin{enumerate}
    \item \textbf{Type assignment}: Each site now has $|R| + 1$ choices (each reserve type or unprotected). This creates:
    \[
    \binom{|R|}{2} \cdot |S| \text{ mutual exclusion constraints}
    \]
    For 4 types and 100 sites: 600 clauses just for exclusivity.

    \item \textbf{Type-specific connectivity}: Core reserves must be connected \emph{to each other}, buffers must surround cores, corridors must link components. This requires:
    \[
    |R| \times |E| \text{ type-specific adjacency constraints}
    \]
    
    \item \textbf{Cross-type reachability}: ``Every core site must be reachable from every other core site via core OR buffer sites.'' This is a Boolean formula over paths:
    \[
    \forall i, j \in \text{cores}: \exists \text{ path } p_{ij}: \bigwedge_{(u,v) \in p_{ij}} (y_{u,\text{core}} \vee y_{u,\text{buffer}}) \land z_{uv}
    \]
    
    This is \textbf{inherently Boolean logic}, not easily expressible as CP global constraints.
\end{enumerate}

\subsubsection{Dense Constraint Graphs}

Multi-type reserves create dense constraint interactions:
\begin{itemize}
    \item Each site interacts with all neighbors across all type combinations
    \item Reachability between types creates long-range dependencies
    \item CP's propagation becomes ineffective on such dense graphs
    \item SAT's clause learning and conflict-driven search excel here
\end{itemize}

\subsection{Concrete Example: Core + Buffer Zones}

Consider just 2 reserve types (core and buffer):

\textbf{CP18 single-type}: 
\begin{itemize}
    \item Variables: $n$ binary variables $x_i$
    \item Connectivity: 1 global constraint (\texttt{connected})
    \item Constraint graph: sparse, tree-like
\end{itemize}

\textbf{Multi-type SAT}:
\begin{itemize}
    \item Variables: $2n$ binary variables ($y_{i,\text{core}}, y_{i,\text{buffer}}$ for each site)
    \item Mutual exclusion: $n$ clauses ($\neg y_{i,\text{core}} \vee \neg y_{i,\text{buffer}}$)
    \item Core connectivity: $n$ reachability clauses for cores
    \item Buffer adjacency: ``Every buffer must neighbor at least one core'':
    \[
    y_{i,\text{buffer}} \rightarrow \bigvee_{(i,j) \in E} y_{j,\text{core}}
    \]
    \item Cross-type reachability: Transitivity clauses linking cores via buffers
    \item Constraint graph: dense, highly interconnected
\end{itemize}

\textbf{Result}: The multi-type problem has $O(n \cdot |R| \cdot |E|)$ Boolean clauses encoding spatial logic that CP cannot efficiently propagate. SAT solvers, designed for exactly this structure, become the natural choice.

\subsection{Theorem: Multi-Type Necessitates SAT Structure}

\begin{theorem}
For reserve design with $|R| \geq 2$ reserve types and type-specific connectivity requirements, the problem constraint graph is $\Omega(|R|^2 \cdot |E|)$-dense, making Boolean satisfiability the native formulation.
\end{theorem}

\begin{proof}
Each edge $(i,j) \in E$ generates constraints for each pair of types $(r_1, r_2) \in R \times R$ to encode ``if site $i$ has type $r_1$ and site $j$ has type $r_2$, then...'' This creates $|R|^2 \cdot |E|$ Boolean implications. These are efficiently encoded as CNF clauses but create a dense constraint graph that overwhelms CP propagation.
\end{proof}

\section{Constraints as Logical Statements}

Each ecological requirement translates directly into a Boolean constraint:

\subsection{Species Representation}

\textbf{Requirement}: Each species $j$ must be represented in at least $t_j$ selected sites.

\textbf{Logical form}: ``At least $t_j$ of the literals $\{x_i : r_{ij} = 1\}$ must be true.''

\textbf{Mathematical form}:
\[
\sum_{i \in S} r_{ij} x_i \geq t_j, \quad \forall j \in P
\]

This is an \textbf{AtLeast-K constraint}, native to SAT solvers.

\subsection{Reserve Type Exclusivity}

\textbf{Requirement}: Each site can be assigned to at most one reserve type.

\textbf{Logical form}: ``For each site $i$, at most one of $\{y_{i1}, y_{i2}, \ldots, y_{ik}\}$ is true.''

\textbf{Mathematical form}:
\[
\sum_{j=1}^{k} y_{ij} \leq 1, \quad \forall i \in S
\]

This encodes as pairwise mutual exclusion: $\neg y_{ij} \vee \neg y_{il}$ for all $j \neq l$.

This encodes as pairwise mutual exclusion: $\neg y_{ij} \vee \neg y_{il}$ for all $j \neq l$.

\subsection{Spatial Connectivity}

\textbf{Requirement}: If a site is selected, at least one of its neighbors must also be selected (to avoid isolated fragments).

\textbf{Logical form}: ``$x_i$ implies (at least one neighbor $x_j$ where $(i,j) \in E$).''

\textbf{Mathematical form}:
\[
x_i \rightarrow \bigvee_{(i,j) \in E} x_j, \quad \forall i \in S
\]

This is a Boolean implication, directly expressible in CNF:
\[
\neg x_i \vee \bigvee_{(i,j) \in E} x_j
\]

\textbf{Auxiliary connectivity variables}: To encode ``both sites selected and adjacent,'' define:
\[
z_{ij} = x_i \land x_j, \quad \forall (i,j) \in E
\]

\subsection{Compactness (Graph Reachability)}

\textbf{Requirement}: Selected sites must form at most $K$ spatially connected components.

\textbf{Logical form}: ``There exist at most $K$ 'root' sites such that every selected site can reach exactly one root via selected neighbors.''

This is a graph reachability constraint, encodable in SAT using:
\begin{enumerate}
    \item Root selection variables: $\rho_i \in \{\text{true}, \text{false}\}$ (is site $i$ a component root?)
    \item Reachability variables: $\text{reach}_{ik} \in \{\text{true}, \text{false}\}$ (can site $i$ reach root $k$?)
    \item Transitivity clauses: If site $i$ reaches root $k$ and site $j$ is a selected neighbor of $i$, then $j$ also reaches $k$:
    \[
    (\text{reach}_{ik} \land z_{ij}) \rightarrow \text{reach}_{jk}
    \]
    \item Coverage: Every selected site reaches at least one root:
    \[
    x_i \rightarrow \bigvee_{k \in S} \text{reach}_{ik}
    \]
    \item Root limit: At most $K$ sites are roots:
    \[
    \sum_{i \in S} \rho_i \leq K
    \]
\end{enumerate}

\subsection{Budget Constraint}

\textbf{Requirement}: Total cost of selected sites must not exceed budget $B$.

\textbf{Logical form}: ``The weighted sum of selected sites is at most $B$.''

For integer costs, this is a \textbf{pseudo-Boolean constraint}, natively supported by many SAT solvers:
\[
\sum_{i \in S} c_i x_i \leq B
\]

\section{K-SAT Formulation}

\subsection{Direct Translation to CNF}

Since reserve design constraints are already logical, translation to K-SAT is \emph{direct}, not a complex conversion:

\subsubsection{Boolean Variables}

Decision variables map one-to-one to Boolean literals:
\begin{itemize}
    \item $x_i$ (site $i$ selected) $\leftrightarrow$ Boolean variable $x_i$
    \item $y_{ij}$ (site $i$ has reserve type $j$) $\leftrightarrow$ Boolean variable $y_{ij}$
    \item $z_{ij}$ (sites $i, j$ both selected and adjacent) $\leftrightarrow$ Boolean variable $z_{ij}$
\end{itemize}

\subsubsection{Mutual Exclusion Clauses}

Each site belongs to at most one reserve type. For site $i$ and reserve types $j, l$ where $j \neq l$:
\[
\neg y_{ij} \vee \neg y_{il}
\]

This generates $\binom{k}{2}$ clauses per site, all of size 2 (very efficient).

\subsubsection{Species Representation (AtLeast-K) Clauses}

For species $j$ requiring coverage in at least $t_j$ sites, let $V_j = \{i \in S : r_{ij} = 1\}$ be sites containing species $j$.

The constraint ``at least $t_j$ of the variables in $\{x_i : i \in V_j\}$ must be true'' is an \textbf{AtLeast-K} constraint.

\textbf{Direct encoding} (for small $t_j$): Enumerate all $\binom{|V_j|}{|V_j| - t_j + 1}$ minimal satisfying sets. Each generates a clause.

\textbf{Cardinality network encoding} (for larger $t_j$): Modern SAT solvers natively support cardinality constraints and encode them efficiently using sorting networks or totalizers.

For SAT solvers without native support, the constraint can be encoded using auxiliary variables (details abstracted here, handled by solver internals).

\subsubsection{Connectivity (Implication) Clauses}

\textbf{Neighbor requirement}: If site $i$ is selected, at least one neighbor must be selected:
\[
x_i \rightarrow \bigvee_{(i,j) \in E} x_j
\]

In CNF:
\[
\neg x_i \vee \bigvee_{(i,j) \in E} x_j
\]

Clause size = $1 + |\text{neighbors of } i|$ (typically small for planar spatial graphs).

\textbf{Adjacency variables}: $z_{ij} = x_i \land x_j$ encodes as three 2-clauses and one 3-clause:
\begin{align}
&\neg z_{ij} \vee x_i \\
&\neg z_{ij} \vee x_j \\
&\neg x_i \vee \neg x_j \vee z_{ij}
\end{align}

\begin{align}
&\neg z_{ij} \lor x_i \tag{If $z_{ij}$ then $x_i$}\\
&\neg z_{ij} \lor x_j \tag{If $z_{ij}$ then $x_j$}\\
&\neg x_i \lor \neg x_j \lor z_{ij} \tag{If $x_i$ and $x_j$ then $z_{ij}$}
\end{align}

\subsection{Compactness Constraint Encoding}

Compactness is more complex. We use a graph connectivity encoding:

\begin{enumerate}
    \item Select one site as a "root" for each connected component
    \item Use reachability variables $r_{ij}^k$ indicating if site $i$ can reach root $k$
    \item Add transitivity clauses
\end{enumerate}

\begin{align}
&\neg x_i \vee \neg x_j \vee z_{ij}
\end{align}

\subsubsection{Compactness (Reachability) Clauses}

For at most $K$ connected components:

\textbf{Root variables}: $\rho_i$ indicates if site $i$ is a component root.

\textbf{Reachability variables}: $\text{reach}_{ik}$ indicates if site $i$ can reach root $k$.

\textbf{CNF clauses}:
\begin{enumerate}
    \item Every selected site reaches at least one root:
    \[
    \neg x_i \vee \bigvee_{k \in S} \text{reach}_{ik}
    \]
    
    \item Roots reach themselves:
    \[
    \neg \rho_k \vee \text{reach}_{kk}
    \]
    
    \item Reachability transitivity: If site $i$ reaches root $k$ and sites $i, j$ are both selected and adjacent, then $j$ reaches $k$:
    \[
    \neg \text{reach}_{ik} \vee \neg z_{ij} \vee \text{reach}_{jk}
    \]
    \item At most $K$ roots (cardinality constraint):
    \[
    \sum_{k \in S} \rho_k \leq K
    \]
\end{enumerate}

These are all 2-clauses and 3-clauses, plus one cardinality constraint.

\subsection{Optimization via Satisfiability}

Optimization is secondary to satisfiability in this formulation. Two approaches:

\subsubsection{Iterative Constraint Tightening}

\begin{algorithm}
\caption{SAT-based Optimization}
\begin{algorithmic}[1]
\State Initialize budget $B$ to an upper bound
\State $\text{best\_solution} \leftarrow \text{null}$
\While{SAT solver finds solution}
    \State Store current solution
    \State Compute cost $C$ of current solution
    \State Add constraint: $\sum_{i \in S} c_i x_i < C$ \Comment{Find cheaper solution}
    \State Re-solve SAT instance
\EndWhile
\State \Return best\_solution
\end{algorithmic}
\end{algorithm}

\subsubsection{Satisfiability First, Optimization Second}

Alternatively, find \emph{any} satisfying solution first (ignoring cost), then use local search or post-processing to reduce cost while maintaining feasibility. This is appropriate when ecological constraints are paramount and budget is a soft preference.

\subsection{Complete K-SAT Instance}

The reserve design problem as a K-SAT instance:

\begin{enumerate}
    \item \textbf{Variables}: 
    \begin{itemize}
        \item Site selection: $\{x_i : i \in S\}$
        \item Reserve types: $\{y_{ij} : i \in S, j \in R\}$
        \item Adjacency: $\{z_{ij} : (i,j) \in E\}$
        \item Roots: $\{\rho_i : i \in S\}$
        \item Reachability: $\{\text{reach}_{ik} : i, k \in S\}$
    \end{itemize}
    
    \item \textbf{Clauses}:
    \begin{itemize}
        \item Mutual exclusion (2-clauses): $\neg y_{ij} \vee \neg y_{il}$ for all sites, reserve type pairs
        \item Species representation (AtLeast-K constraints): For each species
        \item Connectivity implications (variable-size clauses): $\neg x_i \vee \bigvee_{j \in N(i)} x_j$
        \item Adjacency encoding (2- and 3-clauses): $z_{ij} = x_i \land x_j$
        \item Reachability propagation (3-clauses): Transitivity of reachability
        \item Root limit (cardinality): $\sum_i \rho_i \leq K$
        \item Budget (pseudo-Boolean): $\sum_i c_i x_i \leq B$
    \end{itemize}
\end{enumerate}

\textbf{Typical clause sizes}: 2-SAT and 3-SAT dominate, with occasional larger clauses for high-degree spatial nodes or species occurring in many sites. This is well-suited to modern SAT solvers.

\subsection{Equivalence to Conservation Problem}

\begin{theorem}
A satisfying assignment to the K-SAT instance corresponds exactly to a feasible reserve design.
\end{theorem}

\begin{proof}
By construction:
\begin{itemize}
    \item Each Boolean variable represents a discrete conservation decision.
    \item Each clause encodes a necessary ecological or spatial constraint.
    \item No approximation or relaxation is introduced.
\end{itemize}
Thus, SAT satisfaction $\Leftrightarrow$ reserve feasibility.
\end{proof}

\section{Discussion: Why SAT is Natural for Conservation}

\subsection{Evolution from CP to SAT}

The constraint programming approach of \cite{justeau2018} successfully handles single-type reserve design. However, as conservation practice evolved to include:
\begin{itemize}
    \item \textbf{Multiple management zones} (IUCN categories I-VI)
    \item \textbf{Multi-use landscapes} (core reserves, buffer zones, sustainable use areas)
    \item \textbf{Connectivity corridors} linking fragmented habitats
    \item \textbf{Restoration areas} with different protection levels
\end{itemize}

...the problem structure shifted from CP-friendly to SAT-native. This is not a modeling choice—it's a consequence of the combinatorial explosion of type-specific logical constraints.

\textbf{Key insight}: CP excels at single-type problems with global constraints (e.g., \texttt{connected}). SAT excels at multi-type problems with dense Boolean interactions. Real-world conservation requires the latter.

\subsection{Discrete Decisions}

Conservation planning involves yes/no decisions: protect this site or not, designate it as core or buffer. These are \emph{not} continuous variables that happen to be constrained to $\{0, 1\}$—they are genuinely discrete alternatives. SAT solvers handle this natively.

\subsection{Logical Constraints}

Ecological requirements are inherently logical:
\begin{itemize}
    \item ``Species A \textbf{must} be represented'' (hard constraint, not soft penalty)
    \item ``Sites \textbf{must} be connected'' (Boolean reachability, not approximate distance)
    \item ``A site \textbf{cannot} be both strict reserve and logging area'' (logical XOR)
\end{itemize}

These map directly to Boolean clauses, not linear inequalities.

\subsection{Spatial Relationships}

Spatial constraints—adjacency, connectivity, compactness—are graph properties, naturally expressed in Boolean logic:
\begin{itemize}
    \item Adjacency graph $E$ defines which sites are neighbors (Boolean relation)
    \item Connectivity is reachability via Boolean AND operations
    \item Compactness is counting connected components (graph search, Boolean)
\end{itemize}

\textbf{Multi-type amplification}: With $|R|$ reserve types, spatial relationships multiply:
\begin{itemize}
    \item Type-specific adjacency: ``Cores must neighbor cores or buffers, not restoration areas''
    \item Cross-type reachability: ``Every core must reach every other core via cores or corridors''
    \item Hierarchical connectivity: ``Buffers must form a connected ring around cores''
\end{itemize}

These create $O(|R|^2 \cdot |E|)$ Boolean clauses—exactly what SAT solvers are designed to handle.

\subsection{Quantum Annealing Connection}

SAT problems map naturally to quantum annealing:
\begin{itemize}
    \item Clauses $\rightarrow$ energy penalties
    \item Boolean variables $\rightarrow$ qubits
    \item Satisfying assignment $\rightarrow$ ground state
\end{itemize}

This makes D-Wave and other quantum annealers \emph{native solvers} for conservation, not just exotic alternatives.

\section{Conclusion}

Reserve design is fundamentally a Boolean satisfiability problem. The decisions are discrete, the constraints are logical, and the spatial relationships are graph-theoretic. This is \emph{not} a conversion from MILP—it is the \textbf{natural representation} of the problem.

\textbf{Historical context}: The single-type CP formulation of \cite{justeau2018} was appropriate for its time and problem scope. However, modern conservation requires multi-type, multi-objective planning, which \emph{necessitates} SAT structure. This is not a preference—it's a mathematical consequence of problem complexity.

This perspective suggests:
\begin{enumerate}
    \item SAT solvers (classical and quantum) are first-class tools for conservation, not secondary to integer programming.
    \item Conservation problems can leverage decades of SAT solver innovations (CDCL, learned clauses, conflict analysis).
    \item Quantum annealers can address conservation directly, without awkward reformulations.
    \item The transition from single-type CP to multi-type SAT mirrors the evolution of conservation practice itself.
\end{enumerate}

Future work should explore hybrid classical-quantum SAT solving for large-scale reserve networks and multi-objective conservation planning as multi-clause satisfaction.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
